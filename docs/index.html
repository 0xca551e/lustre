<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lustre</title>

    <link rel="stylesheet" href="./assets/styles.css" />

    <!-- Start Single Page Apps for GitHub Pages -->
    <script type="text/javascript">
      // Single Page Apps for GitHub Pages
      // MIT License
      // https://github.com/rafgraph/spa-github-pages
      // This script checks to see if a redirect is present in the query string,
      // converts it back into the correct url and adds it to the
      // browser's history using window.history.replaceState(...),
      // which won't cause the browser to attempt to load the new url.
      // When the single page app is loaded further down in this file,
      // the correct url will be waiting in the browser's history for
      // the single page app to route accordingly.
      if (window.location.search[1] === "/") {
        const decoded = window.location.search
          .slice(1)
          .split("&")
          .map((s) => s.replace(/~and~/g, "&"))
          .join("?");

        window.history.replaceState(
          null,
          null,
          window.location.pathname.slice(0, -1) + decoded + window.location.hash
        );
      }
    </script>
    <!-- End Single Page Apps for GitHub Pages -->

    <script type="module">
      import {
        main,
        Route,
        OnRouteChange,
        OnRouteHover,
      } from "./src/app.gleam";

      const strip_base = (path) =>
        `/${path.slice(import.meta.env.BASE_URL.length)}`;

      document.addEventListener("DOMContentLoaded", () => {
        const url = new URL(window.location.href);

        const dispatch = main({
          path: strip_base(url.pathname),
          hash: url.hash,
        });

        // We want to trap click events on anchor elements so we can do our own
        // client side routing.
        document.addEventListener("click", (e) => {
          let target = e.target;

          while (target) {
            if (target === document.body) return;
            if (target.tagName === "A") {
              const url = new URL(target.href);
              if (url.origin !== window.location.origin) return;
              const route = new Route(strip_base(url.pathname), url.hash);

              e.preventDefault();
              window.requestAnimationFrame(() => {
                window.history.pushState({}, "", url.href);

                if (url.pathname === window.location.pathname && url.hash) {
                  document.querySelector(url.hash)?.scrollIntoView();
                } else {
                  window.scrollTo(0, 0);
                }
              });

              return void dispatch(new OnRouteChange(route));
            }

            target = target.parentNode;
          }
        });

        document.addEventListener("mouseover", (e) => {
          let target = e.target;

          while (target) {
            if (target === document.body) return;
            if (target.tagName === "A") {
              const url = new URL(target.href);
              if (url.origin !== window.location.origin) return;
              const route = new Route(strip_base(url.pathname), url.hash);
              return void dispatch(new OnRouteHover(route));
            }

            target = target.parentNode;
          }
        });

        // This lets us listen to the back and forward buttons in the browser
        // and trigger our app's routing.
        window.addEventListener("popstate", () => {
          const url = new URL(window.location.href);
          const route = new Route(strip_base(url.pathname), url.hash);

          dispatch(new OnRouteChange(route));
        });
      });
    </script>
  </head>
  <body></body>
</html>
